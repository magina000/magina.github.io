<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue+axios实现登录拦截]]></title>
    <url>%2F2019%2F10%2F15%2Fvue-axios%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%2F</url>
    <content type="text"><![CDATA[vue+axios 前端实现登录拦截（包括路由拦截、http拦截）整体思路： 登录时，发送登录请求，成功后将后台返回的登录用户信息（token）存在sessionStorage中。 接口请求时，在axios请求拦截器中给http头携带token发送给后台，用于验证登录状态是否过期（request interceptors）。 请求时token如果过期，清除sessionstorage的用户信息，并重定向到登录页。 路由跳转时，利用vue-router提供的钩子函数beforeEach()对路由进行判断，非登录页且存在token就next()，不存在token便跳转到登录页面。 vuex先把要管理的登录状态写完整(store-&gt;index.js) 123456789101112131415161718import Vue from "vue";import Vuex from "vuex";Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; token: window.sessionStorage.getItem('token') &#125;, mutations: &#123; login(state, data)&#123; state.token = data; window.sessionStorage.setItem('token', data); &#125;, logout(state)&#123; window.sessionStorage.removeItem('token'); &#125; &#125;&#125;) 登录 Login.vue 123456789101112131415//login接口请求登录信息,存储tokenlogin()&#123; this.$http.post('/api/login').then(res =&gt; &#123; this.$store.commit('login', res.token); // index为首页，或者重定向传过来的跳转页面 let redirect = decodeURIComponent(this.$route.query.redirect || '/index'); this.$router.push(&#123; path: redirect &#125;) &#125;).catch(err=&gt;&#123; //登出 this.$store.commit('logout'); &#125;)&#125;&#125;) http拦截 axios封装 123456789101112131415161718192021222324252627282930313233343536373839404142//请求拦截axios.interceptors.request.use(config =&gt; &#123; //存在token，写入请求头 if(store.state.token)&#123; config.headers.Authorization = `$&#123;store.state.token&#125;` &#125; return config&#125;)//返回拦截axios.interceptors.response.use( response =&gt; &#123; return response; &#125;, err =&gt; &#123; if(err.response)&#123; switch (error.response.status) &#123; // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 case 401: router.replace(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: store.commit('logout'); router.replace(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); &#125; return Promise.reject(error.response.data) // 返回接口返回的错误信息 &#125;&#125;) 路由拦截 router&gt;index.js 12345678//路由跳转之前//如果token不存在且不是登录页，跳转登录页router.beforeEach((to, from, next) =&gt; &#123; if (to.path !== '/login' &amp;&amp; !store.state.token) &#123; return next('/login') &#125; next()&#125;)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中axios请求封装]]></title>
    <url>%2F2019%2F09%2F23%2Fvue%E4%B8%ADaxios%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[axios的封装和api接口的统一管理，主要目的是简化代码和利于后期的更新维护。默认已经安装axios 引入在项目的src目录中，新建一个api文件夹，然后在里面新建一个http.js，index.js文件。http.js文件用来封装axios，index.js用来统一管理接口 12345// 在http.js中引入axiosimport axios from 'axios'; // 引入axiosimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到// ElementUI的message提示框组件，可根据使用的ui组件更改。import &#123; Message &#125; from 'element-ui'; 环境切换通过node的环境变量来匹配默认的接口url前缀。axios.defaults.baseURL设置axios的默认请求地址。 123456//环境切换(主要是开发和生产环境) e.g.if (process.env.NODE_ENV == 'development') &#123; axios.defaults.baseURL = '/api';&#125; else if (process.env.NODE_ENV == 'production') &#123; axios.defaults.baseURL = '';&#125; 创建实例并设置请求超时1var instance = axios.create(&#123;timeout: 1000 * 12&#125;); POST请求头的设置1instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'; 请求拦截在发送请求前可以进行一个请求的拦截，为什么要拦截呢，拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，需要序列化我们提交的数据。这时候，可以在请求被发送之前进行一个拦截，从而进行想要的操作。 1234567891011121314// 如果用到store缓存登录信息,先导入vueximport store from '@/store/index';instance.interceptors.request.use( config =&gt; &#123; // 每次发送请求之前判断vuex中是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; &#125;, error =&gt; &#123; return Promise.error(error); &#125;) 补充：说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。 响应拦截将服务器返回给我们的数据进行处理。如果后台返回的状态码是200，则正常返回数据，否则根据错误的状态码类型进行一些需要的错误捕捉提示，同时包括没登录或登录过期后重定向登录页。报错提示 123456const tip = msg =&gt; &#123; Message(&#123; message: msg, duration: 1000 &#125;);&#125; 跳转登录页 12345678const toLogin = () =&gt; &#123; router.replace(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;);&#125; 错误状态码捕捉 12345678910111213141516171819202122232425const errorHandle = (status, message) =&gt; &#123; // 状态码判断 switch (status) &#123; // 401: 未登录状态，跳转登录页 case 401: toLogin(); break; // 403 token过期 // 清除token并跳转登录页 case 403: tip('登录过期，请重新登录'); localStorage.removeItem('token'); store.commit('loginSuccess', null); setTimeout(() =&gt; &#123; toLogin(); &#125;, 1000); break; // 404请求不存在 case 404: tip('请求的资源不存在'); break; default: console.log(message); &#125;&#125; 完整拦截 1234567891011121314151617181920212223242526// 响应拦截器instance.interceptors.response.use( // 请求成功 res =&gt; res.status === 200 ? Promise.resolve(res) : Promise.reject(res), // 请求失败 err =&gt; &#123; const &#123; response &#125; = err; if (response) &#123; // 请求已发出，但是不在2xx的范围 errorHandle(response.status, response.data.message); return Promise.reject(response); &#125; else &#123; // 处理断网的情况 // eg:请求超时或断网时，更新state的network状态 // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏 // 关于断网组件中的刷新重新获取数据，会在断网组件中说明 if (!window.navigator.onLine) &#123; store.commit('changeNetwork', false); &#125; else &#123; return Promise.reject(err); &#125; &#125; &#125;)//拦截器完成后即可抛出axiosexport default instance; api管理index.js中 12345678910111213141516171819202122import axios from '@/api/http'; // 导入http中创建的axios实例import qs from 'qs'; // 导入qs模块进行请求参数格式化，或者根据需求自定义//get，post本就是promise，不需要过度封装直接使用//e.g.const getDemo = (params) &#123; return axios.get(`url`, &#123; params: params &#125;).then( res =&gt; res.data; ); &#125;, const postDemo = (params) &#123; return axios.post(`url`, qs.stringify(params) ).then( res =&gt; res.data; )&#125;export default&#123; getDemo, postDemo&#125; 页面中调用为了方便api的调用，需要将其挂载到vue的原型上。在main.js中： 12import api from './api' // 导入api接口Vue.prototype.$http = api; // 将api挂载到vue的原型上 页面中调用 123456789methods: &#123; func() &#123; this.$http.getDemo(&#123; param: 123 &#125;).then(res=&gt; &#123; //执行某些操作 &#125;) &#125; &#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解js中的this]]></title>
    <url>%2F2019%2F08%2F15%2F%E8%AF%A6%E8%A7%A3js%E4%B8%AD%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[主要解释在JS里面this关键字的指向问题(在浏览器环境下)函数的几种调用方式 普通函数调用 作为方法来调用 作为构造函数来调用 使用apply/call方法来调用 Function.prototype.bind方法 es6箭头函数 重点：谁调用这个函数或方法,this关键字就指向谁。 普通函数调用 1234567function person()&#123; this.name="xl"; console.log(this); console.log(this.name);&#125;person(); //输出 window xl 在这段代码中person函数作为普通函数调用，实际上person是作为全局对象window的一个方法来进行调用的,即window.person();所以这个地方是window对象调用了person方法,那么person函数当中的this即指window,同时window还拥有了另外一个属性name,值为xl。 作为方法调用 12345678var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;person.showName(); //输出 xl 这里是person对象调用showName方法，很显然this关键字是指向person对象的，所以会输出name。 12var showNameA=person.showName;showNameA(); //输出 XL 这里将person.showName方法赋给showNameA变量，此时showNameA变量相当于window对象的一个属性，因此showNameA()执行的时候相当于window.showNameA(),即window对象调用showNameA这个方法，所以this关键字指向window。 换种写法: 123456789101112var personA=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;var personB=&#123; name:"XL", sayName:personA.showName&#125;personB.sayName(); //输出 XL 虽然showName方法是在personA这个对象中定义，但是调用的时候却是在personB这个对象中调用，因此this对象指向personB。 作为构造函数调用 123456function Person(name)&#123; this.name=name;&#125;var personA=Person("xl");console.log(personA.name); // 输出 undefinedconsole.log(window.name);//输出 xl 上面代码没有进行new操作，相当于window对象调用Person(&quot;xl&quot;)方法，那么this指向window对象，并进行赋值操作window.name=&quot;xl&quot;。 new操作符： 12345678910//下面这段代码模拟了new操作符(实例化对象)的内部过程function person(name)&#123; var o=&#123;&#125;; o.__proto__=Person.prototype; //原型继承 Person.call(o,name); return o;&#125;var personB=person("xl");console.log(personB.name); // 输出 xl 在person里面首先创建一个空对象o，将o的proto指向Person.prototype完成对原型的属性和方法的继承 Person.call(o,name)这里即函数Person作为apply/call调用(具体内容下方)，将Person对象里的this改为o，即完成了o.name=name操作 返回对象o。 call/apply方法的调用 在JS里函数也是对象，因此函数也有方法。从Function.prototype上继承到Function.prototype.call/Function.prototype.apply方法call/apply方法最大的作用就是能改变this关键字的指向。 Obj.method.apply(AnotherObj,arguments); 12345678910var name="XL";var Person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;Person.showName.call(); //输出 "XL"//这里call方法里面的第一个参数为空，默认指向window。//虽然showName方法定义在Person对象里面，但是使用call方法后，将showName方法里面的this指向了window。因此最后会输出"XL"; 举例： 12345678910111213141516171819funtion FruitA(n1,n2)&#123; this.n1=n1; this.n2=n2; this.change=function(x,y)&#123; this.n1=x; this.n2=y; &#125;&#125;var fruitA=new FruitA("cheery","banana");var FruitB=&#123; n1:"apple", n2:"orange"&#125;;fruitA.change.call(FruitB,"pear","peach");console.log(FruitB.n1); //输出 pearconsole.log(FruitB.n2);// 输出 peach//FruitB调用fruitA的change方法，将fruitA中的this绑定到对象FruitB上。 Function.prototype.bind()方法 1234567891011var name="XL";function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log("my name is "+this.name); &#125;,50) &#125;&#125;var person=new Person("xl");person.sayName() //输出 “my name is XL”; 这里的setTimeout()定时函数,相当于window.setTimeout(),由window这个全局对象对调用,因此this的指向为window, 则this.name则为XL。那么如何才能输出&quot;my name is xl&quot;呢？ 123456789101112var name="XL";function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log("my name is "+this.name); &#125;.bind(this),50) //注意这个地方使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Person对象 &#125;&#125;var person=new Person("xl");person.sayName(); //输出 “my name is xl”; 这里setTimeout(function(){console.log(this.name)}.bind(this),50);,匿名函数使用bind(this)方法后创建了新的函数，这个新的函数不管在什么地方执行，this都指向Person,而非window,因此最后的输出为&quot;my name is xl&quot;而不是&quot;my name is XL&quot;。 另外几个需要注意的地方： setTimeout/setInterval/匿名函数执行的时候，this默认指向window对象，除非手动改变this的指向。在《javascript高级程序设计》当中，写到：“超时调用的代码(setTimeout)都是在全局作用域中执行的，因此函数中的this的值，在非严格模式下是指向window对象，在严格模式下是指向undefined”。本文都是在非严格模式下的情况。 举例： 1234567891011var name="XL";function Person()&#123; this.name="xl"; this.showName=function()&#123; console.log(this.name); &#125; setTimeout(this.showName,50);&#125;var person=new Person(); //输出 "XL"//在setTimeout(this.showName,50)语句中，会延时执行this.showName方法//this.showName方法即构造函数Person()里面定义的方法。50ms后，执行this.showName方法，this.showName里面的this此时便指向了window对象。则会输出"XL"; 修改上面的代码： 123456789101112var name="XL";function Person()&#123; this.name="xl"; var that=this; this.showName=function()&#123; console.log(that.name); &#125; setTimeout(this.showName,50)&#125;var person=new Person(); //输出 "xl"//这里在Person函数当中将this赋值给that，即让that保存Person对象//因此在setTimeout(this.showName,50)执行过程当中，console.log(that.name)即会输出Person对象的属性"xl" 匿名函数： 12345678910111213var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125; sayName:function()&#123; (function(callback)&#123; callback(); &#125;)(this.showName) &#125;&#125;person.sayName(); //输出 XL 改变this： 123456789101112131415var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125; sayName:function()&#123; var that=this; (function(callback)&#123; callback(); &#125;)(that.showName) &#125;&#125;person.sayName() ; //输出 "xl"//匿名函数的执行同样在默认情况下this是指向window的，除非手动改变this的绑定对象 箭头函数 es6里面this指向固定化，始终指向外部对象，因为箭头函数没有this,因此它自身不能进行new实例化,同时也不能使用call, apply, bind等方法来改变this的指向 1234567function Timer() &#123; this.seconds = 0; setInterval( () =&gt; this.seconds ++, 1000);&#125; var timer = new Timer();setTimeout( () =&gt; console.log(timer.seconds), 3100);// 3 //在构造函数内部的setInterval()内的回调函数，this始终指向实例化的对象，并获取实例化对象的seconds的属性,每1s这个属性的值都会增加1。否则最后在3s后执行setTimeOut()函数执行后输出的是0]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用gulp解决静态资源缓存问题]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BD%BF%E7%94%A8gulp%E8%A7%A3%E5%86%B3%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[实现办法：自动给 js、css 等静态资源后面加上版本号（gulp 版本 3.9.1）使用前使用后 默认已经安装 Node.js 和 npm 全局安装 gulp1cnpm install gulp -g 在当前项目中安装 gulp1cnpm install --save-dev gulp 查看 gulp 是否安装成功 1gulp -v 出现版本号表示安装成功 CLI 表示全局版本；Local 本地版本（建议一致） 安装三个 gulp 插件 gulp123npm install --save-dev gulp-revnpm install --save-dev gulp-rev-collectornpm install --save-dev run-sequence 下面的文件修改重要！！！&gt; node_modules/gulp-rev/index.js修改第 134 行 12//manifest[originalFile] = revisionedFile;manifest[originalFile] = originalFile + '?v=' + file.revHash; &gt; node_modules/gulp-rev/node_modules/rev-path/index.js修改第 9 行 12//return modifyFilename(pth, (filename, ext) =&gt; `$&#123;filename&#125;-$&#123;hash&#125;$&#123;ext&#125;`);return modifyFilename(pth, (filename, ext) =&gt; `$&#123;filename&#125;$&#123;ext&#125;`); &gt; node_modules/gulp-rev-collector/index.js修改第 40 行 12//var cleanReplacement = path.basename(json[key]).replace(new RegExp( opts.revSuffix ), '' );var cleanReplacement = path.basename(json[key]).split('?')[0]; 修改第 139 行 12//regexp: new RegExp( dirRule.dirRX + pattern, 'g' ),regexp: new RegExp( dirRule.dirRX + pattern +'(\\?v=\\w&#123;10&#125;)?', 'g' ), 第 164 行 12//regexp: new RegExp( prefixDelim + pattern, 'g' ),regexp: new RegExp( prefixDelim + pattern+'(\\?v=\\w&#123;10,&#125;)?', 'g' ), 新建一个 gulpfile.js 文件内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//引入gulp和gulp插件var gulp = require('gulp'), runSequence = require('run-sequence'), rev = require('gulp-rev'), revCollector = require('gulp-rev-collector');//定义css、js源文件路径。这里填写自己真实的路径var cssSrc = '[你的真实项目地址]/static/css/*.css', jsSrc = '[你的真实项目地址]/static/js/*.js';//CSS生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revCss', function()&#123; return gulp.src(cssSrc) .pipe(rev()) .pipe(rev.manifest()) //.pipe(minifycss()) //压缩css，需要新的插件，下载速度太慢，我放弃了 .pipe(gulp.dest('rev/css'));&#125;);//js生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revJs', function()&#123; return gulp.src(jsSrc) .pipe(rev()) .pipe(rev.manifest()) //.pipe(uglify()) ////压缩JS，需要新的插件，下载速度太慢，我放弃了 .pipe(gulp.dest('rev/js'));&#125;);//Html替换css、js文件版本gulp.task('revHtml', function () &#123; return gulp.src(['rev/**/*.json', '[你的真实项目地址]/**/view/**/*.html'])//填写自己的真实模板存放位置 .pipe(revCollector()) .pipe(gulp.dest('[你的真实项目地址]/application'));&#125;);//task合并顺序执行gulp.task('dev', function (done) &#123; condition = false; runSequence( ['revCss'], ['revJs'], ['revHtml'], done);&#125;);gulp.task('default', ['dev']); 执行在项目根目录输入 gulp 就 OK 了]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客（CSS相关）]]></title>
    <url>%2F2019%2F07%2F10%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、水平居中(1)文本/行内元素/行内块级元素原理：text-align只控制行内内容(文字、行内元素、行内块级元素)如何相对他的块父元素对齐 123#parent&#123; text-align: center;&#125; *只对行内内容有效；属性会继承影响到后代行内内容；如果子元素宽度大于父元素宽度则无效，只有后代行内内容中宽度小于设置text-align属性的元素宽度的时候，才会水平居中 (2)单个块级元素1234#son&#123; width: 100px; /*必须定宽*/ margin: 0 auto;&#125; (3)多个块级元素原理：text-align只控制行内内容(文字、行内元素、行内块级元素)如何相对他的块父元素对齐 123456#parent&#123; text-align: center;&#125;.son&#123; display: inline-block; /*改为行内或者行内块级形式，以达到text-align对其生效*/&#125; (4)使用绝对定位实现1234567891011121314#parent&#123; height: 200px; width: 200px; /*定宽*/ position: relative; /*父相*/ background-color: #f00;&#125;#son&#123; position: absolute; /*子绝*/ left: 50%; /*父元素宽度一半,这里等同于left:100px*/ transform: translateX(-50%); /*自身宽度一半,等同于margin-left: -50px;*/ width: 100px; /*定宽*/ height: 100px; background-color: #00ff00;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>常见布局实现</tag>
      </tags>
  </entry>
</search>
