<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浏览器缓存、本地存储和渲染相关]]></title>
    <url>%2F2021%2F01%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E3%80%81%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%92%8C%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[浏览器缓存机制强缓存首先检查的是强缓存，不需要发送HTTP请求，是根据相应字段进行：HTTP/1.0采用的是 Expires HTTP/1.1采用的是 Cache-Control ExpiresExpires-过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如： Expires: Thu, 14 Jan 2021 09:28:00 GMT， 表示资源在2021年1月14号9点28分过期，过期了就得向服务端发请求。这个方式存在问题：服务器的时间和浏览器的时间可能并不一致，就会导致服务器返回的这个过期时间可能就是不准确的。 Cache-Control采用过期时长来控制缓存，对应的字段是max-age。比如： Cache-Control:max-age=3600， 表示这个响应返回后在3600秒内可以直接使用缓存。同时它还有很多指令：public 客户端和代理服务器都可以缓存，中间的任何代理节点都可以进行缓存。no-cache 跳过当前的强缓存，发送HTTP请求，直接进入协商缓存。no-store 不进行任何形式的缓存。s-maxage 用法和max-age一样，但是针对的是代理服务器的缓存时间。 协商缓存强缓存失效之后，浏览器在请求头中携带相应的缓存tag向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存。tag分两种： Last-Modified 和 ETag（我的理解，这其实是中文概念，如果开始使用协商缓存，基本就是缓存失效的意思，要请求服务器了，只不过如果还要使用这个的话，就会带这些请求信息，通过返回的标签值来告诉浏览器做什么行为） Last-Modified最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器之前传来的最后修改时间。服务器拿收到If-Modified-Since后，会和服务器中该资源的最后修改时间对比：如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。否则返回304，告诉浏览器直接用缓存。 ETagETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中发给服务器。服务器接收到If-None-Match后，会和服务器上该资源的ETag进行对比:如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。否则返回304，告诉浏览器直接用缓存。 缓存位置Service Worker Cache 离线缓存Memory Cache 内存缓存（渲染进程结束后，内存缓存就消失）Disk Cache 存储磁盘中的缓存区别: 比较大的JS、CSS文件会直接被丢进磁盘， 内存使用率比较高的时候，文件优先进入磁盘。 总结首先通过 Cache-Control 验证强缓存是否可用如果强缓存可用，直接使用，则进入协商缓存（发送 HTTP 请求），服务器通过请求头中的If-Modified-Since或者If-None-Match字段检查资源是否更新。若资源更新，返回资源和200状态码否则，否则返回304，告诉浏览器直接从缓存获取资源。 本地存储Cookie内部以键值对的方式来存储，向同一个域名下发送请求，都会携带相同的Cookie，服务器拿到Cookie进行解析，便能拿到客户端的状态。容量缺陷 体积上限只有4KB。性能缺陷 Cookie紧跟域名，请求始终会携带上完整的Cookie。安全缺陷 Cookie以纯文本的形式在浏览器和服务器中传递，在被非法篡改后，依然重新发送给服务器。 localStoragelocalStorage针对一个域名持久化存储，容量上限为5M，只存在客户端，默认不参与与服务端的通信。使用： window.localStorage暴露在全局，通过setItem和getItem等方法进行操作。应用场景 内容稳定的资源（图片等）。 sessionStorage区别于localStorage，sessionStorage是会话级存储，会话结束（页面关闭），sessionStorage就消失了。应用场景 表单信息，本次浏览记录（可用于用户行为监控）等 IndexedDB浏览器内的非关系型数据库，存储大型数据应用场景 省市级地区机构等大量数据，离线功能的数据 总结现阶段来说Cookie不适合存储，存在较多缺陷。Web Storage包括localStorage和sessionStorage, 默认不会参与和服务器的通信。IndexedDB使用不够便捷，场景不多。 输入URL-&gt;页面呈现网络相关1. 构建请求浏览器构建请求行: GET / HTTP/1.1 请求方法是GET，路径为根路径，HTTP协议版本为1.12. 查找强缓存先检查强缓存，如果命中直接使用3. DNS解析将域名映射为具体IP4. 建立TCP连接（计算机网络基础）TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议阶段：1.三次握手确认连接。2.数据包校验保证数据到达接收方。3.四次挥手断开连接。5. 发送HTTP请求携带请求头信息，如果是POST（携带请求体）6. 网络响应响应行、响应头和响应体。响应行：HTTP/1.1 200 OK HTTP协议版本，状态码，状态描述。响应完成后，要判断Connection字段, 如果请求头或响应头中包含Connection: Keep-Alive，表示建立了持久连接，TCP连接会一直保持，之后请求统一站点的资源会复用这个连接。否则断开TCP连接, 请求-响应流程结束。 完成响应后，如果响应头中Content-Type: text/html，浏览器开始进行解析+渲染。 “浏览器打开一个网页相当于起了一个进程，每个tab网页都有由其独立的渲染引擎” 浏览器内核（Chrome-webkit/FireFox-gecko）解析-&gt;渲染GUI渲染线程GUI渲染线程负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程就会执行。在Javascript引擎运行脚本期间，GUI渲染线程都是处于挂起状态的。 一、构建DOM树编码： 将HTML的原始字节数据转换为文件指定编码的字符。令牌化： 浏览器会根据HTML规范来将字符串转换成各种令牌(如&lt;html&gt;、&lt;body&gt;这样的标签以及标签中的字符串和属性等都会被转化为令牌)。生成对象： 接下来每个令牌都会被转换成定义其属性和规则的节点对象。构建完毕： DOM树构建完成。如图： 二、构建CSSOM树当HTML代码遇见&lt;link&gt;标签时，浏览器会获取标签中的CSS文件，构建CSSOM树。如图： 三、布局构建完DOM树和CSSOM树后，两者节后就是渲染树（Render Tree）如图： 1.浏览器会先从DOM树的根节点开始遍历每个可见节点（除了display：none属性节点）2.对每个可见节点，找到其适配的CSS样式规则并应用。3.从渲染树的根节点开始遍历，确定每个节点对象在页面上的确切大小与位置，过程中不断输出盒模型。 四、绘制将渲染树绘制成像素，绘制所需的时间跟CSS样式的复杂度成正比，绘制完成后-&gt;页面最终呈现效果。 Javascript引擎线程（Javascript单线程）当浏览器的HTML解析器遇到script标记时就会暂停构建DOM,此时控制权移交Javascript引擎，并开始执行Javascript脚本，直到执行结束后才会继续构建DOM。所以每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。所以Javascript一般放在body尾部。 定时触发器线程浏览器定时计数器并不是由Javascript引擎计数的, 因为Javascript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时。 事件触发线程当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待Javascript引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、Ajax异步请求等，但由于Javascript的单线程关系所有这些事件都得排队等待JS引擎处理。 异步http请求线程XMLHttpRequest连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到Javascript引擎的处理队列中等待处理。 回流与重绘回流（reflow）当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染。界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的回流。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。 重绘（repaint）改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。 注：每次reflow，repaint后浏览器都需要合并渲染层并输出到屏幕上。所有的这些都会是动画卡顿的原因。reflow 的成本比 repaint 的成本高得多。一个节点的 reflow 很有可能导致子节点，父节点以及同级所有节点的 reflow。 触发时机举例：1. display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint ，因为没有发生位置变化。2. 有时修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow,这叫异步 reflow 或增量异步 reflow。3. 比如 resize 窗口，改变了页面默认的字体等，浏览器会马上进行 reflow 。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[event实现（发布-订阅模式实例）]]></title>
    <url>%2F2020%2F05%2F29%2Fevent%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通过event的实现，加深自己对发布-订阅模式的理解 其实js的addEventListener就是一种发布订阅模式的实现，对dom元素进行某个指令的监听。 基本构造构造函数初始化Event的事件清单和监听者上限。 1234function EventEmeitter() &#123; this._events = this._events || new Map(); // 储存事件/回调键值对 this._maxListeners = this._maxListeners || 10; // 设立监听上限&#125; 监听触发触发监听函数我们可以用apply与call两种方法,在少数参数时call的性能更好,多个参数时apply性能更好。 12345678910111213141516171819// 触发名为type的事件EventEmeitter.prototype.emit = function(type, ...args) &#123; let handler; // 从储存事件键值对的this._events中获取对应事件回调函数 handler = this._events.get(type); if (args.length &gt; 0) &#123; handler.apply(this, args); &#125; else &#123; handler.call(this); &#125; return true;&#125;;// 监听名为type的事件EventEmeitter.prototype.addListener = function(type, fn) &#123; // 将type事件以及对应的fn函数放入this._events中储存 if (!this._events.get(type)) &#123; this._events.set(type, fn); &#125;&#125;; 简单实践12345678910// 实例化const emitter = new EventEmeitter();// 监听一个名为arson的事件对应一个回调函数emitter.addListener('target', val =&gt; &#123; console.log(`监听函数 $&#123;val&#125;`);&#125;);// 我们触发target事件,发现回调成功执行emitter.emit('target', '123'); // 监听函数 123 问题-&gt;多个监听者123456789// 重复监听同一个事件名emitter.addListener('target', man =&gt; &#123; console.log(`监听函数1 $&#123;man&#125;`);&#125;);emitter.addListener('target', man =&gt; &#123; console.log(`监听函数2 $&#123;man&#125;`);&#125;);emitter.emit('target', '123'); // 监听函数1 123 只会触发第一次监听，所以要在绑定时需要使用数组存储不同的监听函数。 升级优化addListener实现方法还不够健全,在绑定第一个监听者之后,就无法对后续监听者进行绑定了,因此需要将后续监听者与第一个监听者函数放到一个数组里. 123456789101112131415// 监听名为type的事件EventEmeitter.prototype.addListener = function(type, fn) &#123; const handler = this._events.get(type); if (!handler) &#123; this._events.set(type, fn); &#125; else if (handler &amp;&amp; typeof handler === 'function') &#123; // 如果handler是函数说明只有一个监听者 this._events.set(type, [handler, fn]); // 多个监听者我们需要用数组储存 &#125; else &#123; if (handler.length === this._maxListeners) &#123; return false; &#125; handler.push(fn); // 已经有多个监听者,那么直接往数组里push函数即可 &#125;&#125;; 在调用时进行监听者判断 123456789101112131415161718192021EventEmeitter.prototype.emit = function(type, ...args) &#123; let handler; handler = this._events.get(type); if (Array.isArray(handler)) &#123; // 如果是一个数组说明有多个监听者,需要依次此触发里面的函数 for (let i = 0; i &lt; handler.length; i++) &#123; if (args.length &gt; 0) &#123; handler[i].apply(this, args); &#125; else &#123; handler[i].call(this); &#125; &#125; &#125; else &#123; // 单个函数的情况我们直接触发即可 if (args.length &gt; 0) &#123; handler.apply(this, args); &#125; else &#123; handler.call(this); &#125; &#125; return true;&#125;; 问题解决！ 补充-移除监听1234567891011121314151617181920212223242526272829EventEmeitter.prototype.removeListener = function(type, fn) &#123; const handler = this._events.get(type); // 获取对应事件名称的函数清单 // 如果是函数,说明只被监听了一次 if (handler &amp;&amp; typeof handler === 'function') &#123; this._events.delete(type, fn); &#125; else &#123; let position; // 如果handler是数组,说明被监听多次要找到对应的函数 for (let i = 0; i &lt; handler.length; i++) &#123; if (handler[i] === fn) &#123; position = i; &#125; else &#123; postion = -1; &#125; &#125; // 如果找到匹配的函数,从数组中清除 if (position !== -1) &#123; // 找到数组对应的位置,直接清除此回调 handler.splice(position, 1); // 如果清除后只有一个函数,那么取消数组,以函数形式保存 if (handler.length === 1) &#123; this._events.set(type, handler[0]); &#125; &#125; else &#123; return this; &#125; &#125;&#125;; 小问题：匿名函数无法移除]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvvm理解并简易实现数据双向绑定]]></title>
    <url>%2F2020%2F05%2F28%2Fmvvm%E7%90%86%E8%A7%A3%E5%B9%B6%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[近段时间打算花点时间研究一些vue底层的代码，也顺便想为面试准备一下 MVVM（Model-View-ViewModel) ViewModel：内部集成了Binder(Data-binding Engine，数据绑定引擎)，在MVP中派发器View或Model的更新都需要通过Presenter手动设置，而Binder则会实现View和Model的双向绑定，从而实现View或Model的自动更新。 View：可组件化，例如目前各种流行的UI组件框架，View的变化会通过Binder自动更新相应的Model。 Model：Model的变化会被Binder监听(仍然是通过观察者模式)，一旦监听到变化，Binder就会自动实现视图的更新。 发布订阅模式发布—订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。具体可以看另一篇实现event就是典型的该模式的实现。 简易数据双向绑定实现（重点） tips: vue2.0数据劫持还是通过Object.defineProperty实现，不过vue3.0中已经采用Object.proxy来实现，具体区别以后分析 大致内容摘自 github/DMQ 思路整理已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，要实现mvvm的双向绑定，就必须要实现以下几点： 1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 4、mvvm入口函数，整合以上三者。 个人理解 1. Observer数据监听时要对对象的所有属性进行遍历监听，每一个属性都自定义一个订阅器（dep）,将所有订阅者（watcher）都保存在订阅器中，当监听到数据变化时，通知订阅器中的所有订阅者。2. Complie扫描所有元素节点，在这次简易的demo中应该扫描出{ { } }这样格式的文本节点和元素节点下的v-model的这类指令模板，所谓的数据双向绑定也就是”修改input的值-&gt;改变数据”，”数据改变-&gt;视图模板替换”，只实现其一也就是说只实现单向绑定。在扫描所有节点时，对指定属性查找出对应的上述节点时，自动创建订阅者（demo中也就是说有2个订阅者）3. Watcher我理解为这就是订阅者，当Observer发出通知数据已变化后，遍历dep中所有的订阅者执行对应的回调函数。 代码展示 有个小技巧，在数据劫持时，利用订阅器Dep的某个属性（targets）临时赋值Watcher，添加到dep中，添加完后再删除这个属性,因为在new Watcher阶段不太方便在Watcher的原型中取出this并添加到dep中,所以采用new阶段时 调用监听数据的getter方法时添加（具体在代码中会详细备注） observer.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//数据劫持构造函数function Observe(data) &#123; this.data = data; this.init(data);&#125;Observe.prototype = &#123; init: function (data) &#123; var _this = this; Object.keys(data).forEach((key) =&gt; &#123; _this.convert(key, data[key]); &#125;) &#125;, convert(key, val) &#123; this.defineReactive(this.data, key, val); &#125;, defineReactive(data, key, val) &#123; var dep = new Dep(); //定义一个订阅器 observe(val); // 递归继续向下找，实现深度的数据劫持 Object.defineProperty(data, key, &#123; configurable: true, enumerable: true, get: function () &#123; Dep.target &amp;&amp; dep.addWatcher(Dep.target); //这一行在new Watcher阶段触发，将订阅者添加到订阅器中 return val; &#125;, set: function (newVal) &#123; if (newVal == val) return; val = newVal; observe(newVal); // 当设置为新值后，也需要把新值再去定义成属性 dep.notify(); // 数据变化，通知所有订阅者 &#125; &#125;) &#125;&#125;function observe(value) &#123; if (!value || typeof value !== 'object') &#123; return; &#125; return new Observe(value);&#125;;//订阅器构造函数function Dep() &#123; this.watchers = [];&#125;Dep.prototype = &#123; addWatcher: function (watcher) &#123; this.watchers.push(watcher); &#125;, notify: function () &#123; this.watchers.forEach(function (watcher) &#123; //所有订阅者执行对应的更新函数 watcher.update(); &#125;); &#125;&#125; complie.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function Compile(el, mvvm) &#123; this.$vm = mvvm; this.$el = document.querySelector(el); if (this.$el) &#123; //因为遍历解析的过程有多次操作dom节点，为提高性能和效率， //会先将vue实例根节点的el转换成文档碎片fragment进行解析编译操作，解析完成， //再将fragment添加回原来的真实dom节点中 this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; node2Fragment: function (el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;, init: function () &#123; this.compileElement(this.$fragment); &#125;, compileElement: function (el) &#123; var childNodes = el.childNodes, _this = this; [].slice.call(childNodes).forEach((node) =&gt; &#123; var text = node.textContent; var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; if (_this.isElementNode(node)) &#123; //扫描到元素节点 let nodeAttrs = node.attributes; [].slice.call(nodeAttrs).forEach((attr) =&gt; &#123; let name = attr.name; let exp = attr.value; if (name.includes('v-')) &#123; //如果元素节点包含指令 node.value = _this.$vm[exp]; &#125; // 监听变化 new Watcher(_this.$vm, exp, function (newVal) &#123; node.value = newVal; // 当watcher触发时会自动将内容放进输入框中 &#125;); node.addEventListener('input', e =&gt; &#123; let newVal = e.target.value; // 相当于给this.c赋了一个新值 // 而值的改变会调用set，set中又会调用notify，notify中调用watcher的update方法实现了更新 _this.$vm[exp] = newVal; &#125;); &#125;) &#125; else if (_this.isTextNode(node) &amp;&amp; reg.test(text)) &#123; //扫描到相同的文本节点&#123;&#123;exp&#125;&#125; //RegExp.$1表示正则校验第一个匹配值 比如文本节点&#123;&#123;obj.a.b&#125;&#125; //RegExp.$1就是obj，RegExp.$2就是a let arr = RegExp.$1.split('.'); let val = _this.$vm; arr.forEach(key =&gt; &#123; val = val[key]; // 如this.a.b &#125;); // 用trim方法去除一下首尾空格 node.textContent = text.replace(reg, val).trim(); //初始化替换数据 // new订阅者，节点的回调执行为文本替换 new Watcher(_this.$vm, RegExp.$1, newVal =&gt; &#123; node.textContent = text.replace(reg, newVal).trim(); &#125;); &#125; // 如果还有子节点，继续递归扫描 if (node.childNodes &amp;&amp; node.childNodes.length) &#123; _this.compileElement(node); &#125; &#125;) &#125;, isElementNode: function (node) &#123; return node.nodeType == 1; &#125;, isTextNode: function (node) &#123; return node.nodeType == 3; &#125;&#125; watcher.js1234567891011121314151617181920212223242526function Watcher(vm, exp, cb) &#123; this.$vm = vm; this.$exp = exp; this.$cb = cb; this.value = this.get();&#125;Watcher.prototype = &#123; get: function () &#123; Dep.target = this; let value = this.$vm[this.$exp]; // 这里会触发属性的getter，从而添加订阅者 Dep.target = null; return value &#125;, update: function () &#123; var oldVal = this.value; let arr = this.$exp.split('.'); let value = this.$vm; arr.forEach(key =&gt; &#123; value = value[key]; // 通过get获取到新的值 &#125;); if (value !== oldVal) &#123; this.value = value; this.$cb.call(this.$vm, value); // 执行Compile中绑定的回调，更新视图 &#125; &#125;&#125; mvvm.js1234567891011121314151617181920212223242526272829303132333435// 创建一个Mvvm构造函数// 这里用es6方法将options赋一个初始值，防止没传，等同于options || &#123;&#125;function Mvvm(options = &#123;&#125;) &#123; // vm.$options 将所有属性挂载到上面 this.$options = options; // this._data 这里也和Vue一样 let data = this._data = this.$options.data; let _this = this; Object.keys(data).forEach(function (key) &#123; _this._proxy(key); &#125;) // 数据劫持 observe(data); // 解析指令 new Compile(options.el || document.body, this)&#125;//数据代理 把mvvm.a等同于mvvm._data.aMvvm.prototype = &#123; _proxy: function (key) &#123; var _this = this Object.defineProperty(_this, key, &#123; configurable: true, enumerable: true, get: function() &#123; return _this._data[key] &#125;, set: function(newVal) &#123; _this._data[key] = newVal &#125; &#125;) &#125;&#125; index.html123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="mvvm-app"&gt; &lt;input type="text" v-model="name"&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src="./observe.js"&gt;&lt;/script&gt; &lt;script src="./watcher.js"&gt;&lt;/script&gt; &lt;script src="./compile.js"&gt;&lt;/script&gt; &lt;script src="./mvvm.js"&gt;&lt;/script&gt; &lt;script&gt; let mvvm = new Mvvm(&#123; el: '#mvvm-app', data: &#123; name: 'caimj', &#125; &#125;); // console.log(mvvm); // mvvm.name = 'chenym' &lt;/script&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 简单总结1.通过Object.defineProperty的get和set进行数据劫持，实现Observer2.通过遍历节点解析指令添加订阅者3.订阅者构造并塞入订阅器中，收到通知执行对应回调 核心思想：数据劫持+发布订阅模式]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理的路径问题和负载均衡配置]]></title>
    <url>%2F2019%2F12%2F20%2Fnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[最近一次项目上线过程中，配负载均衡的同时，反向代理路径搞错了，特此记录！！！ ## proxy_pass 路径问题proxy_pass http://localhost:8080和proxy_pass http://localhost:8080/(多了末尾的/)是不同的的处理方式，而proxy_pass http://localhost:8080/和proxy_pass http://localhost:8080/abc是相同的处理方式。 总结一下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344server &#123; listen 80; server_name localhost; location /api1/ &#123; proxy_pass http://localhost:8080; &#125; # http://localhost/api1/xxx -&gt; http://localhost:8080/api1/xxx location /api2/ &#123; proxy_pass http://localhost:8080/; &#125; # http://localhost/api2/xxx -&gt; http://localhost:8080/xxx location /api3 &#123; proxy_pass http://localhost:8080; &#125; # http://localhost/api3/xxx -&gt; http://localhost:8080/api3/xxx location /api4 &#123; proxy_pass http://localhost:8080/; &#125; # http://localhost/api4/xxx -&gt; http://localhost:8080//xxx，请注意这里的双斜线，好好分析一下。 location /api5/ &#123; proxy_pass http://localhost:8080/haha; &#125; # http://localhost/api5/xxx -&gt; http://localhost:8080/hahaxxx，请注意这里的haha和xxx之间没有斜杠，分析一下原因。 location /api6/ &#123; proxy_pass http://localhost:8080/haha/; &#125; # http://localhost/api6/xxx -&gt; http://localhost:8080/haha/xxx location /api7 &#123; proxy_pass http://localhost:8080/haha; &#125; # http://localhost/api7/xxx -&gt; http://localhost:8080/haha/xxx location /api8 &#123; proxy_pass http://localhost:8080/haha/; &#125; # http://localhost/api8/xxx -&gt; http://localhost:8080/haha//xxx，请注意这里的双斜杠。&#125; 静态html路径（root和alias区别）root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。 [root]语法：root path默认值：root html配置段：http、server、location、if [alias]语法：alias path配置段：location root实例： 123location /t/ &#123; root /www/root/html/;&#125; 如果一个请求的URI是/t/a.html时，web服务器将会返回服务器上的/www/root/html/t/a.html的文件。 alias实例： 123location /t/ &#123; alias /www/root/html/new_t/;&#125; 如果一个请求的URI是/t/a.html时，web服务器将会返回服务器上的/www/root/html/new_t/a.html的文件。注意这里是new_t，因为alias会把location后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。 注意：1. 使用alias时，目录名后面一定要加”/“。2. alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。3. alias只能位于location块中。（root可以不放在location中） 负载均衡配置1、upstream是关键字必须要有，后面的server_pool为一个Upstream集群组的名字，可以自定义；2、server是关键字固定，后面可以接域名或IP。如果不指定端口，默认是80。结尾有分号。 123456789101112131415http&#123; upstream server_pool &#123; server 192.68.0.14:80; server 192.68.0.15:80; &#125; server &#123; listen 80; server_name localhost; location /api &#123; proxy_pass http://backserver; &#125; &#125;&#125; 1.轮询（默认）2.权重weight和访问比率成正比，用于后端服务器性能不均的情况。权重越高，在被访问的概率越大 1234upstream server_pool &#123; server 192.68.0.14:80 weight=5; server 192.68.0.15:80 weight=10;&#125; 3.ip_hash如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。注意：当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。 12345upstream server_pool &#123; ip_hash; server 192.68.0.14:80; server 192.68.0.15:80;&#125; 4.fair根据后端服务器的响应时间进行分配，响应快的优先分配请求 12345upstream server_pool &#123; server 192.68.0.14:80; server 192.68.0.15:80; fair;&#125; 较完整的一份配置12345upstream server_pool &#123; server 10.0.0.6：80 weight=1 max_fails=1 fails_timeout=10s; server 10.0.0.7：80 weight=1 max_fails=2 fails_timeout=10s backup; server 10.0.0.8：80 weight=1 max_fails=3 fails_timeout=20s backup;&#125; server 10.0.0.6:80:负载均衡后面的RS配置，可以是IP或域名，如果不写端口，默认是80端口。高并发场景下，IP可换成域名，通过DNS做负载均衡 weight=1代表服务器的权重，默认值是1。权重数字越大表示接受的请求比例越大。 max_fails=1Nginx尝试连接后端主机失败的次数，max_fails的默认值是1；企业场景：建议2-3次。 backup这标志着这个服务器作为备份服务器，若主服务器全部宕机了，就会向他转发请求；注意：当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。 fail_timeout=10s在max_fails定义的失败次数后，距离下次检查的间隔时间，默认是10s；如果max_fails是5，他就检测5次。如果5次都是502，那么他就会根据fail_timeout的值，等待10s再去检查，还是只检查一次，如果持续502，在不重新加载nginx配置的情况下，每隔10s都只检测一次。常规业务：2-3秒比较合理。 down这标识着服务器永远不可用，这个参数可配合ip_hash使用。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目elementUI实现树状下拉选择组件（常见机构选择）]]></title>
    <url>%2F2019%2F12%2F03%2Fvue%E9%A1%B9%E7%9B%AEelementUI%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%8A%B6%E4%B8%8B%E6%8B%89%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6%EF%BC%88%E5%B8%B8%E8%A7%81%E6%9C%BA%E6%9E%84%E9%80%89%E6%8B%A9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一直在网上找各种各样的树状下拉组件，多方参考后自己封装自定义组件 treeSelect.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187&lt;template&gt; &lt;div&gt; &lt;el-popover placement="bottom-start" trigger="click" :width="width" @hide="popverHide"&gt; &lt;el-tree ref="tree" class="common-tree" :default-expand-all="defaultExpandAll" :style="treeStyle" :data="treeData" :props="treeProps" :show-checkbox="multiple" :node-key="nodeKey" :default-checked-keys="defaultCheckedKeys" :highlight-current="true" @node-click="handleNodeClick" @check-change="handleCheckChange"&gt; &lt;el-select slot="reference" //reference 触发Popover显示的HTML元素 ref="select" class="tree-select" v-model="selectedData" :multiple="multiple" @click.native="isShowSelect = !isShowSelect"&gt; &lt;el-option v-for="item in options" :key="item.value" :label="item.label" :value="item.value"&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-tree&gt; &lt;/el-popover&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: "treeSelect", props: &#123; //树结构数据--异步加载数据的话需要注释 treeData: &#123; type: Array, default () &#123; return []; &#125; &#125;, treeProps: &#123; type: Object, default()&#123; return &#123;&#125;; &#125; &#125;, // 配置是否可多选 multiple: &#123; type: Boolean, default () &#123; return false; &#125; &#125;, // 配置是否可清空选择 clearable: &#123; type: Boolean, default () &#123; return false; &#125; &#125;, nodeKey: &#123; type: String, default () &#123; return 'id'; &#125; &#125;, // 默认选中的节点key数组 checkedKeys: &#123; type: Array, default () &#123; return []; &#125; &#125;, width: &#123; type: Number, default () &#123; return 250; &#125; &#125;, height: &#123; type: Number, default () &#123; return 300; &#125; &#125; &#125;, data() &#123; return &#123; defaultCheckKeys: [], isShowSelect: false, options: [], selectedData: [], //选中的节点 treeStyle: 'width:' + this.width + 'px;' + 'height:' + this.height + 'px;', selectStyle: 'width:' + (this.width + 24) + 'px;', checkedIds: [], checkedData: [], &#125;; &#125;, created() &#123;&#125;, mounted() &#123; if (this.checkedKeys.length &gt; 0) &#123; if (this.multiple) &#123; this.defaultCheckedKeys = this.checkedKeys; this.selectedData = this.checkedKeys.map((item) =&gt; &#123; var node = this.$refs.tree.getNode(item); return node.label; &#125;); &#125; else &#123; var item = this.checkedKeys[0]; this.$nextTick(() =&gt; &#123; this.$refs.tree.setCurrentKey(item); var node = this.$refs.tree.getNode(item); this.selectedData = node.label; &#125;) &#125; &#125; &#125;, methods: &#123; initData(treeData)&#123; this.treeData = treeData; //异步加载初始化data &#125;, popoverHide()&#123; if (this.multiple) &#123; this.checkedIds = this.$refs.tree.getCheckedKeys(); //所有被选中的节点的 key 所组成的数组数据 this.checkedData = this.$refs.tree.getCheckedNodes(); //所有被选中的节点所组成的数组数据 &#125; else &#123; this.checkedIds = this.$refs.tree.getCurrentKey(); this.checkedData = this.$refs.tree.getCurrentNode(); &#125; this.$emit('popoverHide', this.checkedIds, this.checkedData); &#125;, //节点被点击时的回调,返回被点击的节点数据 handleNodeClick (data, node) &#123; if (!this.multiple) &#123; let tmpMap = &#123;&#125;; tmpMap.value = node.key; tmpMap.label = node.label; this.options = []; this.options.push(tmpMap); this.selectedData = node.label; this.isShowSelect = !this.isShowSelect; &#125; &#125;, //节点选中状态发生变化时的回调 handleCheckChange () &#123; var checkedKeys = this.$refs.tree.getCheckedKeys(); //所有被选中的节点的 key 所组成的数组数据 this.options = checkedKeys.map((item) =&gt; &#123; var node = this.$refs.tree.getNode(item); //所有被选中的节点对应的node let tmpMap = &#123;&#125;; tmpMap.value = node.key; tmpMap.label = node.label; return tmpMap; &#125;); this.selectedData = this.options.map((item) =&gt; &#123; return item.label; &#125;); &#125; &#125;, watch: &#123; isShowSelect (val) &#123; //隐藏select自带的下拉框 this.$refs.select.blur(); &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt; .common-tree&#123; overflow: auto; &#125;&lt;/style&gt; &lt;style&gt; .tree-select .el-select__tags .el-tag .el-tag__close&#123; display: none; &#125; .tree-select .el-select__tags .el-tag .el-icon-close&#123; display: none; &#125;&lt;/style&gt; ##调用方式 common.vue 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;tree-select ref="demoTreeSelect" :defaultProps="defaultProps" :nodeKey="nodeKey" :multiple="true" :defultCheckedKeys="defaultCheckedKeys" @popoverHide="popoverHide"&gt;&lt;/tree-select&gt; &lt;/div&gt;&lt;/template&gt;import TreeSelect from "../treeSelect.vue";export default &#123; data() &#123; defaultProps: &#123; children: 'children', label: 'name' &#125;, nodeKey: 'code', defaultCheckedKeys: [] &#125;, beforeMount() &#123; //异步初始化数据 //api接口调用返回值res.data this.$refs.demoTreeSelect.initData(res.data); &#125;, methods: &#123; popoverHide(checkedIds, checkedData)&#123; console.log(checkedIds); console.log(checkedData); &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vueRouter history模式下的nginx配置]]></title>
    <url>%2F2019%2F10%2F16%2FvueRouter-history%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84nginx%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[主要是Vue路由history模式的踩坑记录，记录下来。 hash模式下的配置123456789//html访问路径location / &#123; root /web/project/**; // 本地项目的路径 index index.html index.htm;&#125;//api接口代理location /api/ &#123; proxy_pass http://192.168.1.1:8080/;（后端接口地址,默认端口号80可以不加）&#125; 注意:如果出现4041.proxy_pass 地址后面要不要加/取决于匹配的 /api/ 作不作为你uri的一部分，如果 /api/ 是其中一部分,则不需要带上 / ； 反之带上。加了 / 相当于是绝对根路径，nginx 不会把location 中匹配的路径 /api/ 带上。2.proxy_pass的地址记得在hosts文件做ip映射，建议直接使用域名对应的ip地址。3.location 中 ~ （区分大小写）与 ~* （不区分大小写）标识均为正则匹配。如果你不确定，请在location后面加上 location ~* /api/ { }这样的配置 不区分 api三个字母的大小写。 history模式下的配置问题在进行项目的主页的时候，一切正常，可以访问，但是当刷新页面或者直接访问路径的时候就会返回404，因为在history模式下，只是动态的通过js操作window.history来改变浏览器地址栏里的路径，并没有发起http请求，但是直接在浏览器里输入这个地址的时候，就一定要对服务器发起http请求，但是这个目标在服务器上又不存在，所以会返回404 解决方案如果项目是根路径,补充try_files $uri $uri/ /index.html; 12345location / &#123; root /web/project/**; // 本地项目的路径 index index.html index.htm; try_files $uri $uri/ /index.html;&#125; 如果项目还带项目名称目录,比如项目访问地址 http://192.168.1.1:8080/project/要注意项目打包后静态资源的路径，修改index.js中build的assetsPublicPath:&quot;/project/&quot; 12345678location /project &#123; root /web/project/**; // 本地项目的路径 index index.html index.htm; if (!-e $request_filename) &#123; rewrite ^(.*) /index.html last; break; &#125;&#125; 问题反向代理后丢失cookie的问题JSESSIONID的path和接口访问的path不同导致 解决方案1、如果只是host、端口转换，则session不会丢失。例如： 123location /testwx &#123; proxy_pass http://127.0.0.1:8080/testwx;&#125; 通过浏览器访问http://127.0.0.1/testwx时，浏览器的cookie内有jsessionid。再次访问时，浏览器会发送当前的cookie。2、如果路径也变化了，则需要设置cookie的路径转换，nginx.conf的配置如下 123location /testwx &#123; proxy_pass http://127.0.0.1:8080/wx;&#125; 通过浏览器访问http://127.0.0.1/testwx时，浏览器的cookie内没有jsessionid。再次访问时，后台当然无法获取到cookie了。加上路径转换：proxy_cookie_path /wx /testwx;则可以将wx的cookie输出到testwx上，Tomcat的session正常了。正确的配置是 1234location /testwx &#123; proxy_pass http://127.0.0.1:8080/wx; proxy_cookie_path /wx /testwx;#这里的路径要注意对应关系&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue+axios实现登录拦截]]></title>
    <url>%2F2019%2F10%2F15%2Fvue-axios%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%2F</url>
    <content type="text"><![CDATA[vue+axios 前端实现登录拦截（包括路由拦截、http拦截） 整体思路： 登录时，判断登录状态（从session中拿登录信息），（若没有登录信息）发送登录请求，成功后将后台返回的登录用户信息（token）存在sessionStorage中。 接口请求时，在axios请求拦截器中给http头携带token发送给后台，用于验证登录状态是否过期（request interceptors）。 请求时token如果过期，清除sessionstorage的用户信息，并重定向到登录页。 路由跳转时，利用vue-router提供的钩子函数beforeEach()对路由进行判断，非登录页且存在token就next()，不存在token便跳转到登录页面。 vuex先把要管理的登录状态写完整(store-&gt;index.js) 12345678910111213141516171819202122232425262728import Vue from "vue";import Vuex from "vuex";Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; token: null， //登录信息(也可以是登录用户信息，由后台定) isLogin: false, //登录状态 &#125;, getters:&#123; //获取登录状态 isLogin(state)&#123; return state.isLogin &#125; &#125;, mutations: &#123; Login(state, data)&#123; sessionStorage.setItem('token',data); state.isLogin = true; state.token = data; &#125;, Logout(state)&#123; sessionStorage.removeItem('token'); state.isLogin = false; state.token = null; &#125; &#125;&#125;) 登录 Login.vue 123456789101112131415161718192021222324252627//判断是否登录methods:&#123; isLogin()&#123; //判断是否由登录信息 if(session.getItem('token'))&#123; this.$store.commit('Login', session.getItem('token')); &#125;else&#123; this.$store.commit('Logout'); &#125; return this.$store.getters.isLogin; &#125;, //login接口请求登录信息,存储token login()&#123; this.$http.post('/api/login').then(res =&gt; &#123; this.$store.commit('Login', res.token); // index为首页，或者重定向传过来的跳转页面 let redirect = decodeURIComponent(this.$route.query.redirect || '/index'); this.$router.push(&#123; path: redirect &#125;) &#125;).catch(err=&gt;&#123; //登出 this.$store.commit('Logout'); &#125;) &#125; &#125;)&#125; http拦截 axios封装 123456789101112131415161718192021222324252627282930313233343536373839404142//请求拦截axios.interceptors.request.use(config =&gt; &#123; //存在token，写入请求头 if(store.state.token)&#123; config.headers.Authorization = `$&#123;store.state.token&#125;` &#125; return config&#125;)//返回拦截axios.interceptors.response.use( response =&gt; &#123; return response; &#125;, err =&gt; &#123; if(err.response)&#123; switch (error.response.status) &#123; // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 case 401: router.replace(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: store.commit('Logout'); router.replace(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); &#125; return Promise.reject(error.response.data) // 返回接口返回的错误信息 &#125;&#125;) 路由拦截 router&gt;index.js 1234567891011121314//路由跳转之前//如果token不存在且不是登录页，跳转登录页//如果有跳转地址要默认登录，就将路由当参数传到登录页router.beforeEach((to, from, next) =&gt; &#123; if (to.path !== '/login' &amp;&amp; !store.state.token) &#123; next(&#123; path: '/login', query: &#123; redirect: to.fullPath &#125; &#125;) &#125; next()&#125;)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中axios请求封装]]></title>
    <url>%2F2019%2F09%2F23%2Fvue%E4%B8%ADaxios%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[axios的封装和api接口的统一管理，主要目的是简化代码和利于后期的更新维护。 默认已经安装axios 引入在项目的src目录中，新建一个api文件夹，然后在里面新建一个http.js，index.js文件。http.js文件用来封装axios，index.js用来统一管理接口 12345// 在http.js中引入axiosimport axios from 'axios'; // 引入axiosimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到// ElementUI的message提示框组件，可根据使用的ui组件更改。import &#123; Message &#125; from 'element-ui'; 环境切换通过node的环境变量来匹配默认的接口url前缀。axios.defaults.baseURL设置axios的默认请求地址。 123456//环境切换(主要是开发和生产环境) e.g.if (process.env.NODE_ENV == 'development') &#123; axios.defaults.baseURL = '/api';&#125; else if (process.env.NODE_ENV == 'production') &#123; axios.defaults.baseURL = '';&#125; 创建实例并设置请求超时1var instance = axios.create(&#123;timeout: 1000 * 12&#125;); POST请求头的设置1instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'; 请求拦截在发送请求前可以进行一个请求的拦截，为什么要拦截呢，拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，需要序列化我们提交的数据。这时候，可以在请求被发送之前进行一个拦截，从而进行想要的操作。 1234567891011121314// 如果用到store缓存登录信息,先导入vueximport store from '@/store/index';instance.interceptors.request.use( config =&gt; &#123; // 每次发送请求之前判断vuex中是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; &#125;, error =&gt; &#123; return Promise.error(error); &#125;) 补充：说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。 响应拦截将服务器返回给我们的数据进行处理。如果后台返回的状态码是200，则正常返回数据，否则根据错误的状态码类型进行一些需要的错误捕捉提示，同时包括没登录或登录过期后重定向登录页。报错提示 123456const tip = msg =&gt; &#123; Message(&#123; message: msg, duration: 1000 &#125;);&#125; 跳转登录页 12345678const toLogin = () =&gt; &#123; router.replace(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;);&#125; 错误状态码捕捉 12345678910111213141516171819202122232425const errorHandle = (status, message) =&gt; &#123; // 状态码判断 switch (status) &#123; // 401: 未登录状态，跳转登录页 case 401: toLogin(); break; // 403 token过期 // 清除token并跳转登录页 case 403: tip('登录过期，请重新登录'); localStorage.removeItem('token'); store.commit('loginSuccess', null); setTimeout(() =&gt; &#123; toLogin(); &#125;, 1000); break; // 404请求不存在 case 404: tip('请求的资源不存在'); break; default: console.log(message); &#125;&#125; 完整拦截 1234567891011121314151617181920212223242526// 响应拦截器instance.interceptors.response.use( // 请求成功 res =&gt; res.status === 200 ? Promise.resolve(res) : Promise.reject(res), // 请求失败 err =&gt; &#123; const &#123; response &#125; = err; if (response) &#123; // 请求已发出，但是不在2xx的范围 errorHandle(response.status, response.data.message); return Promise.reject(response); &#125; else &#123; // 处理断网的情况 // eg:请求超时或断网时，更新state的network状态 // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏 // 关于断网组件中的刷新重新获取数据，会在断网组件中说明 if (!window.navigator.onLine) &#123; store.commit('changeNetwork', false); &#125; else &#123; return Promise.reject(err); &#125; &#125; &#125;)//拦截器完成后即可抛出axiosexport default instance; api管理index.js中 12345678910111213141516171819202122import axios from '@/api/http'; // 导入http中创建的axios实例import qs from 'qs'; // 导入qs模块进行请求参数格式化，或者根据需求自定义//get，post本就是promise，不需要过度封装直接使用//e.g.const getDemo = (params) &#123; return axios.get(`url`, &#123; params: params &#125;).then( res =&gt; res.data; ); &#125;, const postDemo = (params) &#123; return axios.post(`url`, qs.stringify(params) ).then( res =&gt; res.data; )&#125;export default&#123; getDemo, postDemo&#125; 页面中调用为了方便api的调用，需要将其挂载到vue的原型上。在main.js中： 12import api from './api' // 导入api接口Vue.prototype.$http = api; // 将api挂载到vue的原型上 页面中调用 123456789methods: &#123; func() &#123; this.$http.getDemo(&#123; param: 123 &#125;).then(res=&gt; &#123; //执行某些操作 &#125;) &#125; &#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解js中的this]]></title>
    <url>%2F2019%2F08%2F15%2F%E8%AF%A6%E8%A7%A3js%E4%B8%AD%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[主要解释在JS里面this关键字的指向问题(在浏览器环境下)函数的几种调用方式 普通函数调用 作为方法来调用 作为构造函数来调用 使用apply/call方法来调用 Function.prototype.bind方法 es6箭头函数 重点：谁调用这个函数或方法,this关键字就指向谁。 普通函数调用 1234567function person()&#123; this.name="xl"; console.log(this); console.log(this.name);&#125;person(); //输出 window xl 在这段代码中person函数作为普通函数调用，实际上person是作为全局对象window的一个方法来进行调用的,即window.person();所以这个地方是window对象调用了person方法,那么person函数当中的this即指window,同时window还拥有了另外一个属性name,值为xl。 作为方法调用 12345678var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;person.showName(); //输出 xl 这里是person对象调用showName方法，很显然this关键字是指向person对象的，所以会输出name。 12var showNameA=person.showName;showNameA(); //输出 XL 这里将person.showName方法赋给showNameA变量，此时showNameA变量相当于window对象的一个属性，因此showNameA()执行的时候相当于window.showNameA(),即window对象调用showNameA这个方法，所以this关键字指向window。 换种写法: 123456789101112var personA=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;var personB=&#123; name:"XL", sayName:personA.showName&#125;personB.sayName(); //输出 XL 虽然showName方法是在personA这个对象中定义，但是调用的时候却是在personB这个对象中调用，因此this对象指向personB。 作为构造函数调用 123456function Person(name)&#123; this.name=name;&#125;var personA=Person("xl");console.log(personA.name); // 输出 undefinedconsole.log(window.name);//输出 xl 上面代码没有进行new操作，相当于window对象调用Person(&quot;xl&quot;)方法，那么this指向window对象，并进行赋值操作window.name=&quot;xl&quot;。 new操作符： 12345678910//下面这段代码模拟了new操作符(实例化对象)的内部过程function person(name)&#123; var o=&#123;&#125;; o.__proto__=Person.prototype; //原型继承 Person.call(o,name); return o;&#125;var personB=person("xl");console.log(personB.name); // 输出 xl 在person里面首先创建一个空对象o，将o的proto指向Person.prototype完成对原型的属性和方法的继承 Person.call(o,name)这里即函数Person作为apply/call调用(具体内容下方)，将Person对象里的this改为o，即完成了o.name=name操作 返回对象o。 call/apply方法的调用 在JS里函数也是对象，因此函数也有方法。从Function.prototype上继承到Function.prototype.call/Function.prototype.apply方法call/apply方法最大的作用就是能改变this关键字的指向。 Obj.method.apply(AnotherObj,arguments); 12345678910var name="XL";var Person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;Person.showName.call(); //输出 "XL"//这里call方法里面的第一个参数为空，默认指向window。//虽然showName方法定义在Person对象里面，但是使用call方法后，将showName方法里面的this指向了window。因此最后会输出"XL"; 举例： 12345678910111213141516171819funtion FruitA(n1,n2)&#123; this.n1=n1; this.n2=n2; this.change=function(x,y)&#123; this.n1=x; this.n2=y; &#125;&#125;var fruitA=new FruitA("cheery","banana");var FruitB=&#123; n1:"apple", n2:"orange"&#125;;fruitA.change.call(FruitB,"pear","peach");console.log(FruitB.n1); //输出 pearconsole.log(FruitB.n2);// 输出 peach//FruitB调用fruitA的change方法，将fruitA中的this绑定到对象FruitB上。 Function.prototype.bind()方法 1234567891011var name="XL";function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log("my name is "+this.name); &#125;,50) &#125;&#125;var person=new Person("xl");person.sayName() //输出 “my name is XL”; 这里的setTimeout()定时函数,相当于window.setTimeout(),由window这个全局对象对调用,因此this的指向为window, 则this.name则为XL。那么如何才能输出&quot;my name is xl&quot;呢？ 123456789101112var name="XL";function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log("my name is "+this.name); &#125;.bind(this),50) //注意这个地方使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Person对象 &#125;&#125;var person=new Person("xl");person.sayName(); //输出 “my name is xl”; 这里setTimeout(function(){console.log(this.name)}.bind(this),50);,匿名函数使用bind(this)方法后创建了新的函数，这个新的函数不管在什么地方执行，this都指向Person,而非window,因此最后的输出为&quot;my name is xl&quot;而不是&quot;my name is XL&quot;。 另外几个需要注意的地方： setTimeout/setInterval/匿名函数执行的时候，this默认指向window对象，除非手动改变this的指向。在《javascript高级程序设计》当中，写到：“超时调用的代码(setTimeout)都是在全局作用域中执行的，因此函数中的this的值，在非严格模式下是指向window对象，在严格模式下是指向undefined”。本文都是在非严格模式下的情况。 举例： 1234567891011var name="XL";function Person()&#123; this.name="xl"; this.showName=function()&#123; console.log(this.name); &#125; setTimeout(this.showName,50);&#125;var person=new Person(); //输出 "XL"//在setTimeout(this.showName,50)语句中，会延时执行this.showName方法//this.showName方法即构造函数Person()里面定义的方法。50ms后，执行this.showName方法，this.showName里面的this此时便指向了window对象。则会输出"XL"; 修改上面的代码： 123456789101112var name="XL";function Person()&#123; this.name="xl"; var that=this; this.showName=function()&#123; console.log(that.name); &#125; setTimeout(this.showName,50)&#125;var person=new Person(); //输出 "xl"//这里在Person函数当中将this赋值给that，即让that保存Person对象//因此在setTimeout(this.showName,50)执行过程当中，console.log(that.name)即会输出Person对象的属性"xl" 匿名函数： 12345678910111213var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125; sayName:function()&#123; (function(callback)&#123; callback(); &#125;)(this.showName) &#125;&#125;person.sayName(); //输出 XL 改变this： 123456789101112131415var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125; sayName:function()&#123; var that=this; (function(callback)&#123; callback(); &#125;)(that.showName) &#125;&#125;person.sayName() ; //输出 "xl"//匿名函数的执行同样在默认情况下this是指向window的，除非手动改变this的绑定对象 箭头函数 es6里面this指向固定化，始终指向外部对象，因为箭头函数没有this,因此它自身不能进行new实例化,同时也不能使用call, apply, bind等方法来改变this的指向 1234567function Timer() &#123; this.seconds = 0; setInterval( () =&gt; this.seconds ++, 1000);&#125; var timer = new Timer();setTimeout( () =&gt; console.log(timer.seconds), 3100);// 3 //在构造函数内部的setInterval()内的回调函数，this始终指向实例化的对象，并获取实例化对象的seconds的属性,每1s这个属性的值都会增加1。否则最后在3s后执行setTimeOut()函数执行后输出的是0]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用gulp解决静态资源缓存问题]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BD%BF%E7%94%A8gulp%E8%A7%A3%E5%86%B3%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[实现办法：自动给 js、css 等静态资源后面加上版本号（gulp 版本 3.9.1）使用前使用后 默认已经安装 Node.js 和 npm 全局安装 gulp1cnpm install gulp -g 在当前项目中安装 gulp1cnpm install --save-dev gulp 查看 gulp 是否安装成功 1gulp -v 出现版本号表示安装成功 CLI 表示全局版本；Local 本地版本（建议一致） 安装三个 gulp 插件 gulp123npm install --save-dev gulp-revnpm install --save-dev gulp-rev-collectornpm install --save-dev run-sequence 下面的文件修改重要！！！&gt; node_modules/gulp-rev/index.js修改第 134 行 12//manifest[originalFile] = revisionedFile;manifest[originalFile] = originalFile + '?v=' + file.revHash; &gt; node_modules/gulp-rev/node_modules/rev-path/index.js修改第 9 行 12//return modifyFilename(pth, (filename, ext) =&gt; `$&#123;filename&#125;-$&#123;hash&#125;$&#123;ext&#125;`);return modifyFilename(pth, (filename, ext) =&gt; `$&#123;filename&#125;$&#123;ext&#125;`); &gt; node_modules/gulp-rev-collector/index.js修改第 40 行 12//var cleanReplacement = path.basename(json[key]).replace(new RegExp( opts.revSuffix ), '' );var cleanReplacement = path.basename(json[key]).split('?')[0]; 修改第 139 行 12//regexp: new RegExp( dirRule.dirRX + pattern, 'g' ),regexp: new RegExp( dirRule.dirRX + pattern +'(\\?v=\\w&#123;10&#125;)?', 'g' ), 第 164 行 12//regexp: new RegExp( prefixDelim + pattern, 'g' ),regexp: new RegExp( prefixDelim + pattern+'(\\?v=\\w&#123;10,&#125;)?', 'g' ), 新建一个 gulpfile.js 文件内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//引入gulp和gulp插件var gulp = require('gulp'), runSequence = require('run-sequence'), rev = require('gulp-rev'), revCollector = require('gulp-rev-collector');//定义css、js源文件路径。这里填写自己真实的路径var cssSrc = '[你的真实项目地址]/static/css/*.css', jsSrc = '[你的真实项目地址]/static/js/*.js';//CSS生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revCss', function()&#123; return gulp.src(cssSrc) .pipe(rev()) .pipe(rev.manifest()) //.pipe(minifycss()) //压缩css，需要新的插件，下载速度太慢，我放弃了 .pipe(gulp.dest('rev/css'));&#125;);//js生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revJs', function()&#123; return gulp.src(jsSrc) .pipe(rev()) .pipe(rev.manifest()) //.pipe(uglify()) ////压缩JS，需要新的插件，下载速度太慢，我放弃了 .pipe(gulp.dest('rev/js'));&#125;);//Html替换css、js文件版本gulp.task('revHtml', function () &#123; return gulp.src(['rev/**/*.json', '[你的真实项目地址]/**/view/**/*.html'])//填写自己的真实模板存放位置 .pipe(revCollector()) .pipe(gulp.dest('[你的真实项目地址]/application'));&#125;);//task合并顺序执行gulp.task('dev', function (done) &#123; condition = false; runSequence( ['revCss'], ['revJs'], ['revHtml'], done);&#125;);gulp.task('default', ['dev']); 执行在项目根目录输入 gulp 就 OK 了]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见布局实现]]></title>
    <url>%2F2019%2F07%2F10%2F%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[参考链接常见疑难点记录垂直居中(绝对定位适用于所有情况)常用line-height (1)多行文本/行内元素/行内块级元素1234#parent&#123; /*或者用span把所有文字包裹起来，设置display：inline-block转换成图片的方式解决*/ height: 150px; line-height: 30px; /*元素在页面呈现为5行,则line-height的值为height/5*/&#125; (2)图片123456#parent&#123; height: 150px; line-height: 150px; font-size: 0;&#125;img#son&#123;vertical-align: middle;&#125; /*默认是基线对齐，改为middle*/ 水平垂直居中最常用绝对定位和负边距，其次为绝对居中 (1)绝对居中12345678910111213#parent&#123; position: relative;&#125;#son&#123; position: absolute; margin: auto; width: 100px; height: 50px; top: 0; bottom: 0; left: 0; right: 0;&#125; 两列布局左列定宽，右列自适应(1)利用float+margin实现1234567891011121314151617//html&lt;body&gt; &lt;div id="left"&gt;左列定宽&lt;/div&gt; &lt;div id="right"&gt;右列自适应&lt;/div&gt;&lt;/body&gt;//css#left &#123; background-color: #f00; float: left; width: 100px; height: 500px;&#125;#right &#123; background-color: #0f0; height: 500px; margin-left: 100px; /*大于等于#left的宽度*/&#125; (2)使用float+overflow实现(无需关注定宽的宽度s)123456789101112131415161718//html&lt;body&gt; &lt;div id="left"&gt;左列定宽&lt;/div&gt; &lt;div id="right"&gt;右列自适应&lt;/div&gt;&lt;/body&gt;//css#left &#123; background-color: #f00; float: left; width: 100px; height: 500px;&#125;#right &#123; background-color: #0f0; height: 500px; overflow: hidden; /*触发bfc达到自适应*/&#125;/*浮动脱离文档流，需要手动清除浮动，否则会产生高度塌陷；不支持ie6*/ 左列自适应，右列定宽(1)使用float+margin实现12345678910111213141516171819202122232425//html&lt;body&gt;&lt;div id="parent"&gt; &lt;div id="left"&gt;左列自适应&lt;/div&gt; &lt;div id="right"&gt;右列定宽&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;//css#parent&#123; height: 500px; padding-left: 100px; /*抵消#left的margin-left以达到#parent水平居中*/&#125;#left &#123; width: 100%; height: 500px; float: left; margin-left: -100px; /*正值等于#right的宽度*/ background-color: #f00;&#125;#right &#123; height: 500px; width: 100px; float: right; background-color: #0f0;&#125; (2)使用float+overflow实现123456789101112131415161718192021//html&lt;body&gt;&lt;div id="parent"&gt; &lt;div id="right"&gt;右列定宽&lt;/div&gt; &lt;div id="left"&gt;左列自适应&lt;/div&gt; &lt;!--顺序要换一下--&gt;&lt;/div&gt;&lt;/body&gt;//css#left &#123; overflow: hidden; /*触发bfc*/ height: 500px; background-color: #f00;&#125;#right &#123; margin-left: 10px; /*margin需要定义在#right中*/ float: right; width: 100px; height: 500px; background-color: #0f0;&#125;/*浮动脱离文档流，需要手动清除浮动，否则会产生高度塌陷；不支持ie6*/ 一列不定,一列自适应(盒子宽度随着内容增加或减少发生变化,另一个盒子自适应)(1)使用float+overflow实现1234567891011121314151617181920//html&lt;body&gt;&lt;div id="parent"&gt; &lt;div id="left"&gt;左列不定宽&lt;/div&gt; &lt;div id="right"&gt;右列自适应&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;//css#left &#123; margin-right: 10px; float: left; /*只设置浮动,不设宽度*/ height: 500px; background-color: #f00;&#125;#right &#123; overflow: hidden; /*触发bfc*/ height: 500px; background-color: #0f0;&#125;/*浮动脱离文档流，需要手动清除浮动，否则会产生高度塌陷；不支持ie6*/ 三列布局两列定宽,一列自适应(和二列布局相似)两侧定宽,中间自适应双飞翼布局方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//html&lt;body&gt;&lt;div id="header"&gt;&lt;/div&gt;&lt;!--中间栏需要放在前面--&gt;&lt;div id="parent"&gt; &lt;div id="center"&gt; &lt;div id="center_inbox"&gt;中间自适应&lt;/div&gt; &lt;hr&gt; &lt;!--方便观察原理--&gt; &lt;/div&gt; &lt;div id="left"&gt;左列定宽&lt;/div&gt; &lt;div id="right"&gt;右列定宽&lt;/div&gt;&lt;/div&gt;&lt;div id="footer"&gt;&lt;/div&gt;&lt;/body&gt;//css#header &#123; height: 60px; background-color: #ccc;&#125;#left &#123; float: left; width: 100px; height: 500px; margin-left: -100%; /*调整#left的位置,值等于自身宽度*/ background-color: #f00; opacity: 0.5;&#125;#center &#123; height: 500px; float: left; width: 100%; background-color: #eeff2b;&#125;#center_inbox&#123; height: 480px; border: 1px solid #000; margin: 0 220px 0 120px; /*关键!!!左右边界等于左右盒子的宽度,多出来的为盒子间隔*/&#125;#right &#123; float: left; width: 200px; height: 500px; margin-left: -200px; /*使right到指定的位置,值等于自身宽度*/ background-color: #0f0; opacity: 0.5;&#125;#footer &#123; clear: both; /*注意清除浮动!!*/ height: 60px; background-color: #ccc;&#125; 圣杯布局方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//html&lt;body&gt;&lt;div id="header"&gt;&lt;/div&gt;&lt;div id="parent"&gt; &lt;!--#center需要放在前面--&gt; &lt;div id="center"&gt;中间自适应 &lt;hr&gt; &lt;/div&gt; &lt;div id="left"&gt;左列定宽&lt;/div&gt; &lt;div id="right"&gt;右列定宽&lt;/div&gt;&lt;/div&gt;&lt;div id="footer"&gt;&lt;/div&gt;&lt;/body&gt;//css#header&#123; height: 60px; background-color: #ccc;&#125;#parent &#123; box-sizing: border-box; height: 500px; padding: 0 215px 0 115px; /*为了使#center摆正,左右padding分别等于左右盒子的宽,可以结合左右盒子相对定位的left调整间距*/&#125;#left &#123; margin-left: -100%; /*使#left上去一行*/ position: relative; left: -115px; /*相对定位调整#left的位置,正值大于或等于自身宽度*/ float: left; width: 100px; height: 500px; background-color: #f00; opacity: 0.5;&#125;#center &#123; float: left; width: 100%; /*由于#parent的padding,达到自适应的目的*/ height: 500px; box-sizing: border-box; border: 1px solid #000; background-color: #eeff2b;&#125;#right &#123; position: relative; left: 215px; /*相对定位调整#right的位置,大于或等于自身宽度*/ width: 200px; height: 500px; margin-left: -200px; /*使#right上去一行*/ float: left; background-color: #0f0; opacity: 0.5;&#125;#footer&#123; height: 60px; background-color: #ccc;&#125; 多列布局等宽布局(1)使用float实现12345678910111213141516171819202122232425262728//html&lt;body&gt;&lt;div id="parent"&gt; &lt;div class="column"&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;/p&gt;&lt;/div&gt; &lt;div class="column"&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;/p&gt;&lt;/div&gt; &lt;div class="column"&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;/p&gt;&lt;/div&gt; &lt;div class="column"&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;//css#parent &#123; margin-left: -20px; /*使整体内容看起来居中,抵消padding-left的影响*/&#125;.column&#123; padding-left: 20px; /*盒子的边距*/ width: 25%; float: left; box-sizing: border-box; border: 1px solid #000; background-clip: content-box; /*背景色从内容开始绘制,方便观察*/ height: 500px;&#125;.column:nth-child(odd)&#123; background-color: #f00;&#125;.column:nth-child(even)&#123; background-color: #0f0;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
