---
title: 浏览器缓存、本地存储和渲染相关
date: 2021-01-14 09:15:26
categories: 学习
tags: [浏览器]
---

## 浏览器缓存机制

### 强缓存
首先检查的是强缓存，不需要发送HTTP请求，是根据相应字段进行：
HTTP/1.0采用的是 `Expires` HTTP/1.1采用的是 `Cache-Control`

#### Expires
Expires-过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如： `Expires: Thu, 14 Jan 2021 09:28:00 GMT`， 表示资源在**2021年1月14号9点28分**过期，过期了就得向服务端发请求。这个方式存在问题：*服务器的时间和浏览器的时间可能并不一致*，就会导致服务器返回的这个过期时间可能就是不准确的。

#### Cache-Control
采用过期时长来控制缓存，对应的字段是`max-age`。比如： `Cache-Control:max-age=3600`， 表示这个响应返回后在3600秒内可以直接使用缓存。
同时它还有很多指令：
`public` 客户端和代理服务器都可以缓存，中间的任何代理节点都可以进行缓存。
`no-cache` 跳过当前的强缓存，发送HTTP请求，直接进入**协商缓存**。
`no-store` 不进行任何形式的缓存。
`s-maxage` 用法和max-age一样，但是针对的是代理服务器的缓存时间。

### 协商缓存
强缓存失效之后，浏览器在请求头中携带相应的**缓存tag**向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存。tag分两种： `Last-Modified` 和 `ETag`
（我的理解，这其实是中文概念，如果开始使用协商缓存，基本就是缓存失效的意思，要请求服务器了，只不过如果还要使用这个的话，就会带这些请求信息，通过返回的标签值来告诉浏览器做什么行为）

#### Last-Modified
最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。浏览器接收到后，如果再次请求，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器之前传来的最后修改时间。
服务器拿收到`If-Modified-Since`后，会和服务器中该资源的最后修改时间对比：
*如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。否则返回304，告诉浏览器直接用缓存。*

#### ETag
ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。浏览器接收到ETag的值，会在下次请求时，将这个值作为`If-None-Match`这个字段的内容，并放到请求头中发给服务器。
服务器接收到`If-None-Match`后，会和服务器上该资源的ETag进行对比:
*如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。否则返回304，告诉浏览器直接用缓存。*

### 缓存位置
**Service Worker Cache** 离线缓存
**Memory Cache** 内存缓存（渲染进程结束后，内存缓存就消失）
**Disk Cache** 存储磁盘中的缓存
**区别**: 比较大的JS、CSS文件会直接被丢进磁盘， 内存使用率比较高的时候，文件优先进入磁盘。

#### 总结
首先通过 `Cache-Control` 验证强缓存是否可用
如果强缓存可用，直接使用，则进入协商缓存（发送 HTTP 请求），服务器通过请求头中的`If-Modified-Since`或者`If-None-Match`字段检查资源是否更新。
若资源更新，返回资源和200状态码否则，否则返回304，告诉浏览器直接从缓存获取资源。

## 本地存储

### Cookie
内部以键值对的方式来存储，向同一个域名下发送请求，都会携带相同的`Cookie`，服务器拿到`Cookie`进行解析，便能拿到客户端的状态。
**容量缺陷** 体积上限只有4KB。
**性能缺陷** Cookie紧跟域名，请求始终会携带上完整的Cookie。
**安全缺陷** Cookie以纯文本的形式在浏览器和服务器中传递，在被非法篡改后，依然重新发送给服务器。

### localStorage
localStorage针对一个域名**持久化**存储，容量上限为5M，只存在客户端，默认不参与与服务端的通信。
**使用：** `window.localStorage`暴露在全局，通过`setItem`和`getItem`等方法进行操作。
**应用场景** 内容稳定的资源（图片等）。

### sessionStorage
区别于localStorage，sessionStorage是**会话级**存储，会话结束（页面关闭），sessionStorage就消失了。
**应用场景** 表单信息，本次浏览记录（可用于用户行为监控）等

### IndexedDB
浏览器内的非关系型数据库，存储大型数据
**应用场景** 省市级地区机构等大量数据，离线功能的数据

#### 总结
现阶段来说Cookie不适合存储，存在较多缺陷。Web Storage包括localStorage和sessionStorage, 默认不会参与和服务器的通信。IndexedDB使用不够便捷，场景不多。

## 输入URL->页面呈现

### 网络相关
<font size="2">1. 构建请求 
浏览器构建请求行: `GET / HTTP/1.1` 请求方法是GET，路径为根路径，HTTP协议版本为1.1</font>
<font size="2">2. 查找强缓存
先检查强缓存，如果命中直接使用</font>
<font size="2">3. DNS解析
将域名映射为具体IP</font>
<font size="2">4. 建立TCP连接（计算机网络基础）
`TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议`
阶段：
1.`三次握手`确认连接。
2.`数据包校验`保证数据到达接收方。
3.`四次挥手`断开连接。</font>
<font size="2">5. 发送HTTP请求
携带请求头信息，如果是POST（携带请求体）</font>
<font size="2">6. 网络响应
响应行、响应头和响应体。
响应行：` HTTP/1.1 200 OK ` HTTP协议版本，状态码，状态描述。
响应完成后，要判断`Connection`字段, 如果请求头或响应头中包含`Connection: Keep-Alive`，表示建立了持久连接，TCP连接会一直保持，之后请求统一站点的资源会复用这个连接。否则断开TCP连接, 请求-响应流程结束。


**完成响应后，如果响应头中`Content-Type: text/html`，浏览器开始进行解析+渲染。**

“浏览器打开一个网页相当于起了一个进程，每个标签页都有其独立的渲染引擎”

### 浏览器内核（Chrome-webkit/FireFox-gecko）解析->渲染

#### GUI渲染线程
GUI渲染线程负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(Reflow)时，该线程就会执行。在`Javascript`引擎运行脚本期间，GUI渲染线程都是处于挂起状态的。

一、构建DOM树
**编码：** 将`HTML`的原始字节数据转换为文件指定编码的字符。
**令牌化：** 浏览器会根据`HTML`规范来将字符串转换成各种令牌(如`<html>`、`<body>`这样的标签以及标签中的字符串和属性等都会被转化为令牌)。
**生成对象：** 接下来每个令牌都会被转换成定义其属性和规则的节点对象。
**构建完毕：** DOM树构建完成。
如图： ![DOM树构建过程](dom.png)

二、构建CSSOM树
当`HTML`代码遇见`<link>`标签时，浏览器会获取标签中的CSS文件，构建`CSSOM`树。
如图： ![CSSOM树](cssom.png)

三、布局
构建完`DOM`树和`CSSOM`树后，两者结合就是渲染树（Render Tree）
如图： ![Render Tree](render.png)
1.浏览器会先从DOM树的根节点开始遍历每个可见节点（除了display：none属性节点）
2.对每个可见节点，找到其适配的CSS样式规则并应用。
3.从渲染树的根节点开始遍历，确定每个节点对象在页面上的确切大小与位置，过程中不断输出盒模型。

四、绘制
将渲染树绘制成像素，绘制所需的时间跟CSS样式的复杂度成正比，绘制完成后->页面最终呈现效果。

#### Javascript引擎线程（Javascript单线程）
当浏览器的`HTML`解析器遇到`script`标记时就会暂停构建`DOM`,此时控制权移交`Javascript`引擎，并开始执行`Javascript`脚本，直到执行结束后才会继续构建`DOM`。
所以每次去执行`JavaScript`脚本都会严重地阻塞`DOM`树的构建，如果`JavaScript`脚本还操作了`CSSOM`，而正好这个`CSSOM`还没有下载和构建，浏览器甚至会延迟脚本执行和构建`DOM`，直至完成其`CSSOM`的下载和构建。
所以`Javascript`一般放在`body`尾部。

#### 定时触发器线程
浏览器定时计数器并不是由`Javascript`引擎计数的, 因为`Javascript`引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时。

#### 事件触发线程
当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待`Javascript`引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、`Ajax`异步请求等，但由于`Javascript`的单线程关系所有这些事件都得排队等待JS引擎处理。

#### 异步http请求线程
`XMLHttpRequest`连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到`Javascript`引擎的处理队列中等待处理。

### 回流与重绘

#### 回流（reflow）
当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染。界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的回流。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。

#### 重绘（repaint）
改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。

*注：每次reflow，repaint后浏览器都需要合并渲染层并输出到屏幕上。所有的这些都会是动画卡顿的原因。reflow 的成本比 repaint 的成本高得多。一个节点的 reflow 很有可能导致子节点，父节点以及同级所有节点的 reflow。*

**触发时机举例：**
<font size="2">1. `display:none` 会触发 reflow，而 `visibility:hidden` 只会触发 repaint ，因为没有发生位置变化。</font>
<font size="2">2. 有时修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow,这叫异步 reflow 或增量异步 reflow。</font>
<font size="2">3. 比如 `resize` 窗口，改变了页面默认的字体等，浏览器会马上进行 reflow 。</font>